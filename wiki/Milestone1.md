# Milestone 1 ðŸš©

For Milestone 1 our goal was to be able to read the input file + number of processors
and create an output file.  
At this stage, we worked towards producing a valid schedule which did not need to be 
optimal.



## I/O parsing
**Goal for milestone 1**
+ Typing in the appropriate arguments in the command line will be accepted
+ The content of the provided dot file will be read and stored into a data structure
+ Once algorithm finishes, the output file will be generated with a valid schedule

**Solution**

To read the input (.dot file), we decided to use a dynamic graph library called 
[GraphStream](http://graphstream-project.org/).  
Using GraphSteam gave us multiple benefits:
+ Enabled us to have access to the input graph nodes, which saves us from writing the node 
implementation ourselves.
+ No need to use complex regex to parse the input. GraphStream provides an elegant solution
to read files using FileSource 

## Implementation
**Goal for milestone 1**
+ Use the data structure generated from GraphStream, including weights and number of processors
+ Implement an algorithm that generates a valid schedule

**Our algorithm**

From planning, it was decided that our optimal solution was to be generated by combing implementations of
[A*](https://en.wikipedia.org/wiki/A*_search_algorithm) and [DFS](https://en.wikipedia.org/wiki/Depth-first_search).
By analysing DFS, we found out that by generating a decent initial schedule, we are able to bound the
solution tree much quicker. This saves time and memory as we would not need to traverse through
the whole solution tree.  
For milestone 1, it was our focus to generate a decent initial scheduling - an 'ok' solution using . This way, we
are able to meet our milestone 1 goal of generating a valid solution while still working towards our final
optimal solution. 

**Producing an 'ok' solution - implementation**

Let input graph G = (V, E)

1. Find topological order on G
2. Schedule based on the â€˜earliest startâ€™ heuristic (pseudocode below):  
```
Let P = {P0, P1, â€¦ Pn} 
Let Pi = {t0, t1, â€¦ tn} where tj is the jâ€™th task scheduled on Pi
Let earliestStartProc = P0
Let firstFreeProcessor = P1  //added this to optimise incase we have heaps of processors

For task t in topOrder:
	For p in (P up to firstFreeProcessor) :
		if startTime(p, t) < startTime(earliestStart, t)
			earliestStartProc = p
	Add t to earliestStartProc with associated end time
	Update firstFreeProcessor if weâ€™ve scheduled t on an empty processor


// Determines earliest possible scheduling of t in process p
startTime(p, t) {
	let d = D[t] // i.e the tasks which t is dependent on
	int startTime = p.lastTask.endTime
	
	for dependency dâ€™ in d:
		if dâ€™.process != p:
			startTime = max{ startTime, dâ€™.endTime + w(dâ€™, t) }

    return startTime 
}

```

**Future goals**

Our solution is still not optimized and further research can be done to find better solutions.
Our immediate goal is to finish implementing the DFS algorithm to produce an optimal solution, but
further research could prove there are other methods better than our current method. 